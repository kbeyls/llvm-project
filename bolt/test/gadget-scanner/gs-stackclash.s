// RUN: %clang %cflags %s %p/../Inputs/asm_main.c -o %t.exe
// RUN: llvm-bolt-gadget-scanner --scanners=stack-clash %t.exe 2>&1 | FileCheck -check-prefix=CHECK --allow-empty %s

        .text

        .global f_fixed_large_stack
        .type   f_fixed_large_stack , %function
f_fixed_large_stack :
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        ldr     x0, [sp, 32704]
        add     sp, sp, 32768
        add     sp, sp, 32768
        add     sp, sp, 32768
        add     sp, sp, 32768
        ret
        .size   f_fixed_large_stack , .-f_fixed_large_stack
// CHECK-LABEL: GS-STACKCLASH: large SP increase without necessary accesses found in function f_fixed_large_stack
// CHECK-NEXT:    The following instruction(s) increase the stack:
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    This instruction changes the SP next, making the closest-to-top-of-stack access happen at an offset of 131072, which is larger than the assumed page size (65536):
// CHECK-NEXT:    * {{[0-9a-f]+}}:       ldr     x0, [sp, #0x7fc0]

// Verify correct handling of variable growth of the stack:
// Test 1: check that the code as generated by gcc -O2 for the following C code
//         is analyzed correctly:
// long f(long a) {
//  long*v=alloca(a);
//  return v[a-3];
// }
//
        .global f_variable_large_stack
        .type   f_variable_large_stack , %function
f_variable_large_stack :
        stp     x29, x30, [sp, #-16]!
        add     x1, x0, #0xf
        and     x1, x1, #0xfffffffffffffff0
        mov     x29, sp
        sub     sp, sp, x1
        mov     x1, sp
        add     x0, x1, x0, lsl #3
        ldur    w0, [x0, #-24]
        mov     sp, x29
        ldp     x29, x30, [sp], #16
        ret
        .size   f_variable_large_stack , .-f_variable_large_stack
// CHECK-LABEL:  GS-STACKCLASH: non-constant SP change found in function f_variable_large_stack
// CHECK-NEXT:  instruction     {{[0-9a-f]+}}:     sub     sp, sp, x1

// TODO: Verify correct handling of some basic "constants-through-registers" cases, which
// appear in most -fstack-clash-protection generated code.
// The below assembly gets generated by gcc -O2 -fstack-clash-protection on the same
// source code as the above example

        .global f_variable_large_stack_protected
        .type   f_variable_large_stack_protected , %function
f_variable_large_stack_protected :
        stp     x29, x30, [sp, -16]!
        add     x1, x0, 15
        and     x2, x1, -65536
        mov     x29, sp
        sub     sp, sp, #16
        and     x1, x1, -16
        sub     x2, sp, x2
        cmp     sp, x2
        beq     .L3
.L7:
        sub     sp, sp, #65536
        str     xzr, [sp, 1024]
        cmp     sp, x2
        bne     .L7
.L3:
        and     x1, x1, 65535
        sub     sp, sp, x1
        str     xzr, [sp]
        cmp     x1, 1024
        bcs     .L8
        mov     x1, sp
        add     x0, x1, x0, lsl 3
        ldr     w0, [x0, -8]
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
.L8:
        str     xzr, [sp, 1024]
        mov     x1, sp
        add     x0, x1, x0, lsl 3
        ldr     w0, [x0, -8]
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
        .size   f_variable_large_stack_protected, .-f_variable_large_stack_protected


        .global f_verify_detect_fp_corruption
        .type   f_verify_detect_fp_corruption , %function
f_verify_detect_fp_corruption :
        stp     x29, x30, [sp, -16]!
        mov     x29, sp
        mov     x29, x0
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
        .size   f_verify_detect_fp_corruption, .-f_verify_detect_fp_corruption

// CHECK:       GS-STACKCLASH: non-constant SP change found in function f_verify_detect_fp_corruption
// CHECK-NEXT:    instruction     {{[0-9a-f]+}}:     mov     sp, x29


// verify that no other issues are reported:
// CHECK-NOT: GS-STACKCLASH:


// TODO: mov     x12, 32000
// CHEck stack adjustment by register with contant: sub     sp, sp, x12



// TODO: check access with constant:
//        add     x0, sp, 16384
//        ldr     w0, [x0, 15608]

