// RUN: %clang %cflags %s %p/../Inputs/asm_main.c -o %t.exe
// RUN: llvm-bolt-gadget-scanner --scanners=stack-clash %t.exe 2>&1 | FileCheck -check-prefix=CHECK --allow-empty %s

        .text

        .global f_fixed_large_stack
        .type   f_fixed_large_stack , %function
f_fixed_large_stack:
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        sub     sp, sp, #32768
        ldr     x0, [sp, 32704]
        add     sp, sp, 32768
        add     sp, sp, 32768
        add     sp, sp, 32768
        add     sp, sp, 32768
        ret
        .size   f_fixed_large_stack , .-f_fixed_large_stack
// CHECK-LABEL: GS-STACKCLASH: large SP increase without necessary accesses found in function f_fixed_large_stack
// CHECK-NEXT:    The following instruction(s) increase the stack:
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    * {{[0-9a-f]+}}:      sub     sp, sp, #0x8, lsl #12
// CHECK-NEXT:    This instruction changes the SP next, making the closest-to-top-of-stack access happen at an offset of 131072, which is larger than the assumed page size (65536):
// CHECK-NEXT:    * {{[0-9a-f]+}}:       ldr     x0, [sp, #0x7fc0]

// Verify correct handling of variable growth of the stack:
// Test 1: check that the code as generated by gcc -O2 for the following C code
//         is analyzed correctly:
// long f(long a) {
//  long*v=alloca(a);
//  return v[a-3];
// }
//
        .global f_variable_large_stack
        .type   f_variable_large_stack , %function
f_variable_large_stack:
        stp     x29, x30, [sp, #-16]!
        add     x1, x0, #0xf
        and     x1, x1, #0xfffffffffffffff0
        sub     sp, sp, x1
        mov     x1, sp
        add     x0, x1, x0, lsl #3
        ldur    w0, [x0, #-24]
        ldp     x29, x30, [sp], #16
        ret
        .size   f_variable_large_stack , .-f_variable_large_stack
// CHECK-LABEL:  GS-STACKCLASH: non-constant SP change found in function f_variable_large_stack
// Verify that the address printed is not all zeros:
// CHECK-NEXT:  instruction     {{0*[1-9a-fA-F][0-9a-fA-F]+}}:     sub     sp, sp, x1

// The below assembly gets generated by gcc -O2 -fstack-clash-protection on the same
// source code as the above example

        .global f_variable_large_stack_protected
        .type   f_variable_large_stack_protected , %function
f_variable_large_stack_protected:
        stp     x29, x30, [sp, -16]!
        add     x1, x0, 15
        and     x2, x1, -65536
        mov     x29, sp
        sub     sp, sp, #16
        and     x1, x1, -16
        sub     x2, sp, x2
        cmp     sp, x2
        beq     .L3
.L7:
        sub     sp, sp, #65536
        str     xzr, [sp, 1024]
        cmp     sp, x2
        bne     .L7
.L3:
        and     x1, x1, 65535
        sub     sp, sp, x1
        str     xzr, [sp]
        cmp     x1, 1024
        bcs     .L8
        mov     x1, sp
        add     x0, x1, x0, lsl 3
        ldr     w0, [x0, -8]
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
.L8:
        str     xzr, [sp, 1024]
        mov     x1, sp
        add     x0, x1, x0, lsl 3
        ldr     w0, [x0, -8]
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
        .size   f_variable_large_stack_protected, .-f_variable_large_stack_protected
// CHECK-NOT: GS-STACKCLASH:

        .global f_verify_detect_fp_corruption
        .type   f_verify_detect_fp_corruption , %function
f_verify_detect_fp_corruption:
        stp     x29, x30, [sp, -16]!
        mov     x29, sp
        mov     x29, x0
        mov     sp, x29
        ldp     x29, x30, [sp], 16
        ret
        .size   f_verify_detect_fp_corruption, .-f_verify_detect_fp_corruption
// CHECK-LABEL: GS-STACKCLASH: non-constant SP change found in function f_verify_detect_fp_corruption
// CHECK-NEXT:    instruction     {{[0-9a-f]+}}:     mov     sp, x29

        .global f_recognize_fp
        .type   f_recognize_fp , %function
f_recognize_fp:
        stp     x29, x30, [sp, -16]!
        mov     x29, sp
        add     x29, x29, #0x10
        bne     .L1
        ldr     x0, [x29, #4]
.L1:
        // mov     sp, x29
        sub     sp, x29, #0x10
        ldp     x29, x30, [sp], 16
        ret
        .size   f_recognize_fp, .-f_recognize_fp
// CHECK-NOT: GS-STACKCLASH:


        .global f_constant_in_reg
        .type   f_constant_in_reg , %function
f_constant_in_reg:
        stp     x29, x30, [sp, -16]!
        mov     x12, #40000
        sub     sp, sp, x12
        add     sp, sp, x12
        ldp     x29, x30, [sp], 16
        ret
        .size   f_constant_in_reg, .-f_constant_in_reg

// CHECK-NOT: GS-STACKCLASH:

        .global f_recognize_fp_deadcode
        .type   f_recognize_fp_deadcode , %function
f_recognize_fp_deadcode:
       mov     x29, sp
       b    .Lfp3_1
.Ldeadcode:
       nop
.Lfp3_1:
       mov     sp, x29
       ret
       .size   f_recognize_fp_deadcode, .-f_recognize_fp_deadcode

// CHECK-NOT: GS-STACKCLASH:

        .global f_alloca_in_loop
        .type   f_alloca_in_loop, %function
f_alloca_in_loop:
        stp     x29, x30, [sp, -32]!
        mov     x29, sp
        stp     x19, x20, [sp, 16]
        mov     x19, x0
        sub     sp, sp, #16
.L6:
        add     x1, x19, 15
        mov     x20, sp
        and     x2, x1, -65536
        and     x1, x1, -16
        sub     x2, sp, x2
        cmp     sp, x2
        beq     .L4
.L16:
        sub     sp, sp, #65536
        str     xzr, [sp, 1024]
        cmp     sp, x2
        bne     .L16
.L4:
        and     x1, x1, 65535
        sub     sp, sp, x1
        str     xzr, [sp]
        cmp     x1, 1024
        bcc     .L5
        str     xzr, [sp, 1024]
.L5:
        add     x0, sp, 16
        bl      g
        subs    x19, x19, #1
        mov     sp, x20       // There should not be a warning here.
        bne     .L6
        mov     sp, x29
        ldp     x19, x20, [sp, 16]
        ldp     x29, x30, [sp], 32
        ret
        .size   f_alloca_in_loop, .-f_alloca_in_loop

// CHECK-NOT: GS-STACKCLASH:

        .global f_align_sp
        .type   f_align_sp, %function
f_align_sp:
        stp     x29, x30, [sp, #-0x30]!
        mov     x29, sp
        sub     x9, sp, #0x1d0
        and     sp, x9, #0xffffffffffffff80
        ldp     x29, x30, [sp], 32
        ret
        .size   f_align_sp, .-f_align_sp


// TODO: also add a test case with nested alloca loops.

// TODO: check access with constant offset from SP through other
//       register:
//        add     x0, sp, 16384
//        ldr     w0, [x0, 15608]

